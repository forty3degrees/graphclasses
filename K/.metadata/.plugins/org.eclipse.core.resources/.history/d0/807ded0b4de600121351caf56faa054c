/*
 * Displays ISGCI graphs.
 *
 * $Header: /home/ux/CVSROOT/teo/teo/isgci/gui/ISGCIGraphCanvas.java,v 2.1 2012/10/28 16:00:51 ux Exp $
 *
 * This file is part of the Information System on Graph Classes and their
 * Inclusions (ISGCI) at http://www.graphclasses.org.
 * Email: isgci@graphclasses.org
 */

package teo.graph.structure;

import java.awt.Component;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.*;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;

import javax.swing.*;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.ArrayList;
import java.util.List;
import org.xml.sax.SAXException;
import org.jgrapht.VertexFactory;
import org.jgrapht.graph.SimpleDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import teo.isgci.db.*;
import teo.isgci.problem.Complexity;
import teo.isgci.problem.Problem;
import teo.isgci.xml.GraphMLWriter;
import teo.isgci.util.IntFunction;
import teo.isgci.gc.GraphClass;
import teo.isgci.grapht.ISGCIVertexFactory;
import teo.isgci.grapht.GAlg;
import teo.isgci.grapht.Inclusion;
import teo.isgci.gui.ISGCIMainFrame;
import teo.isgci.gui.MessageDialog;
import teo.isgci.gui.SColor;

/**
 * A canvas that can display an inclusion graph.
 */
public class ViewManager {
    protected Problem problem;
    protected Algo.NamePref namingPref;
    protected List<GraphView> graphs;
    protected boolean drawUnproper;

    /** Colours for different complexities */
    public static final Color COLOR_LIN = Color.green;
    public static final Color COLOR_P = Color.green.darker();
    public static final Color COLOR_NPC = Color.red;
    public static final Color COLOR_INTERMEDIATE = SColor.brighter(Color.red);
    public static final Color COLOR_UNKNOWN = Color.white;
    private ISGCIMainFrame myPar;


    public ViewManager() {
        super();
        problem = null;
        namingPref = Algo.NamePref.BASIC;
        graphs = new ArrayList<GraphView>();
        drawUnproper = true;
    }

    public String getCurrentGraphML() {
    	
//    	try {
//            out = new OutputStreamWriter(f, "UTF-8");
//            GraphMLWriter w = new GraphMLWriter(out,GraphMLWriter.MODE_YED,
//                    this.getDrawUnproper(),true);
//
//            w.startDocument();
//            this.write(w);
//            w.endDocument();
//        } catch (IOException ex)  {
//            res = ex;
//        } finally {
//            out.close();
//        }
    	return null;
    }
    
    /** Gets a list of all the current views */
    public Collection<GraphView> getCurrentViews() {
    	return Collections.unmodifiableCollection(this.graphs);
    }
    
    /** Gets a flat list of all the nodes in the current views */
    public Collection<NodeView> getCurrentNodes() {
    	
    	/* Get a list of all the nodes in all graph views */
    	ArrayList<NodeView> result = new ArrayList<NodeView>();
    	for (GraphView gv : graphs) {
    		for (NodeView node : gv.nodes) {
        		if (!result.contains(node)) {
        			result.add(node);
        		}        			
        	}
    	}
    	return result;
    }

    /**
     * Add the given graph to this canvas.
     */
    protected GraphView addGraph(SimpleDirectedGraph<Set<GraphClass>,DefaultEdge> g) {
    	GraphView gv = new GraphView(g);
    	
        gv.setIncludeUnproper(drawUnproper);
        graphs.add(gv);
        
        for (NodeView nv : gv.getNodeViews()) {
            //nv.setColor(complexityColor(nv.getNode()));
            nv.setNameAndLabel(Algo.getName(nv.getNode(), namingPref)); 
        }
        return gv;
    }
    
    /**
     * Return the NodeView for the given node.
     */
    public NodeView getView(Set<GraphClass> node) {
        for (GraphView gv : graphs) {
            NodeView view = gv.getView(node);
            if (view != null)
                return view;
        }
        return null;
    }



    public void setDrawUnproper(boolean b) {
        drawUnproper = b;
        for (GraphView gv : graphs)
            gv.setIncludeUnproper(b);
    }

    public boolean getDrawUnproper() {
        return drawUnproper;
    }

    /**
     * Write this to w.
     */
    public void write(GraphMLWriter w) throws SAXException {
        for (GraphView gv : graphs)
            gv.write(w);
    }
   
    

    /**
     * Create a hierarchy subgraph of the given classes
     */
    public void load(Collection<GraphClass> nodes) {
    	
        SimpleDirectedGraph<Set<GraphClass>, DefaultEdge> graph =
            Algo.createHierarchySubgraph(nodes);

        List<SimpleDirectedGraph<Set<GraphClass>,DefaultEdge>> list =
                GAlg.split(graph, DefaultEdge.class);
        
        try {

            graphs.clear();
            for (SimpleDirectedGraph<Set<GraphClass>, DefaultEdge> g : list) {
                addGraph(g);
            }
        } catch (Error e) {

            if (e instanceof OutOfMemoryError || e instanceof StackOverflowError) {
            	graphs.clear();
            } else {
                throw(e);
            }
        }
    }

    /**
     * Set all nodes to their prefered names.
     */
    public void setPreferedNames() {
        for (GraphView gv : graphs)
            for (NodeView v : gv.getNodeViews())
               v.setNameAndLabel(Algo.getName(v.getNode(), namingPref)); 
    }


    /**
     * Find the NodeView for the given graph class or null if not found
     */
    public NodeView findNode(GraphClass gc) {
        for (GraphView gv : graphs) {
            for (NodeView v : gv.getNodeViews())
                if (v.getNode().contains(gc))
                    return v;
        }
        return null;
    }
     

    /**
     * Bit of a hack to get all ISGCI stuff in one place:
     * Set the appropriate properness of the given edgeview.
     */
    protected void setProperness(EdgeView view) {
    	SimpleDirectedGraph<GraphClass, Inclusion> inclusionGraph = 
    					ISGCIMainFrame.DataProvider.getInclusionGraph();
        List<Inclusion> path = GAlg.getPath(inclusionGraph,
                view.getFrom().iterator().next(),
                view.getTo().iterator().next());
        view.setProper(Algo.isPathProper(path)  ||
                Algo.isPathProper(Algo.makePathProper(path)));
    }


    /**
     * Set coloring for p and repaint.
     */
    public void setProblem(Problem p) {
        if (problem != p) {
            problem = p;
            setComplexityColors();
            if (this.export()) {
            	myPar.loadInitialGraph();
            }
        }
    }
    
	 public boolean export() {
	     boolean res = true;
	     FileOutputStream f;
	     try {
	     	
	     	File  myFile = new File("U:/myGraph.graphml");
	         f = new FileOutputStream(myFile);
	     } catch (Exception e) {
	         e.printStackTrace();
	         return false;
	     }
	
	     try {
	            exportGML(f);            
	     } catch (Exception e) {
	         res = false;
	         e.printStackTrace();
	     }
	     return res;
	 }

 /**
  * Export to GraphML.
  */
 protected void exportGML(FileOutputStream f) throws Exception {
     Exception res = null;
     Writer out = null;
     
     try {
         out = new OutputStreamWriter(f, "UTF-8");
         GraphMLWriter w = new GraphMLWriter(out,GraphMLWriter.MODE_YED,
                 this.getDrawUnproper(),true);

         w.startDocument();
         this.write(w);
         w.endDocument();
     } catch (IOException ex)  {
         res = ex;
     } finally {
         out.close();
     }
     
     if (res != null)
         throw res;
 }

    public Problem getProblem() {
        return problem;
    }


    /**
     * Return the color for node considering its complexity for the active
     * problem.
     */
    protected Color complexityColor(Set<GraphClass> node) {
        if (problem == null)
            return COLOR_UNKNOWN;
        Complexity complexity= problem.getComplexity(node.iterator().next());
        if (/*complexity == null  ||*/  complexity.isUnknown())
            return COLOR_UNKNOWN;
        if (complexity.betterOrEqual(Complexity.LINEAR))
            return COLOR_LIN;
        if (complexity.betterOrEqual(Complexity.P))
            return COLOR_P;
        if (complexity.equals(Complexity.GIC))
            return COLOR_INTERMEDIATE;
        if (complexity.likelyNotP())
            return COLOR_NPC;
        return COLOR_UNKNOWN;
    }


    /**
     * Set all nodes to the proper complexity color.
     */
    public void setComplexityColors() {
        for (GraphView gv : graphs)
            for (NodeView v : gv.getNodeViews())
               v.setColor(complexityColor(v.getNode()));
    }


    public void setNamingPref(Algo.NamePref pref) {
        namingPref = pref;
        setPreferedNames();
//        if (myPar.export()) {
//        	myPar.loadInitialGraph();
//        }
    }

    public Algo.NamePref getNamingPref() {
        return namingPref;
    }


}

/* EOF */
