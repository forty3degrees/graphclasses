package teo.data.services;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;

import org.jgrapht.graph.SimpleDirectedGraph;

import teo.isgci.db.AbstractRelation;
import teo.isgci.gc.GraphClass;
import teo.isgci.grapht.BFSWalker;
import teo.isgci.grapht.GraphWalker;
import teo.isgci.grapht.Inclusion;
import teo.isgci.grapht.RevBFSWalker;
import teo.isgci.problem.Complexity;
import teo.isgci.problem.Problem;

public abstract class DataProvider implements IDataProvider {

	protected boolean initialized;
    
    protected String date;
	protected int nodeCount;
	protected int edgeCount;
	

    /** The inclusion graph */
    public SimpleDirectedGraph<GraphClass,Inclusion> inclGraph;
    /** Maps classnames to nodes */
    protected TreeMap<String,GraphClass> names;
    /** Maps graphclasses to their SCCs */
    protected Map<GraphClass, Set<GraphClass> > sccs;

    /** Problems */
    public Vector<Problem> problems;

    /** Relations not in inclGraph */
    public List<AbstractRelation> relations;

	/**
	 * Loads the data from the specified file into memory.
	 * 
	 * @param	data	The data required by the derived class to load the 
	 * 					application data (file path, connection string etc.)
	 */
	@Override
	public abstract void loadData(String data) throws Exception;

	@Override
	public AbstractRelation findRelation(GraphClass x, GraphClass y) {
		// TODO Auto-generated method stub
		return null;
	}

    /**
     * Returns the nodes of the available graphclasses ordered alphabetically.
     */
	@Override
	public Collection<GraphClass> getGraphClasses() {
		return Collections.unmodifiableCollection(this.names.values());
	}

    /**
     * Return the node in inclGraph belonging to the given classname.
     */
	@Override
    public GraphClass getClass(String name) {
        return this.names.get(name);
    }

    /**
     * Return the set of classes equivalent to the given one.
     */
	@Override
    public Set<GraphClass> getEquivalentClasses(GraphClass graph) {
        return this.sccs.get(graph);
    }
    
	@Override
	public Collection<Problem> getProblems() {
		return Collections.unmodifiableCollection(this.problems);
	}

	@Override
	public Collection<GraphClass> getSubClasses(GraphClass graph, final Boolean recursive) {

		final HashSet<GraphClass> result = new HashSet<GraphClass>();
		
		result.add(graph);
		new BFSWalker<GraphClass,Inclusion>( this.inclGraph,
                graph, null, GraphWalker.InitCode.DYNAMIC) {
            public void visit(GraphClass v) {
                result.add(v);
                if (recursive)
                {
                	super.visit(v);
                }
            }
        }.run();
        
        return result;
	}

	@Override
	public Collection<GraphClass> getSuperClasses(GraphClass graph, final Boolean recursive) {

		final HashSet<GraphClass> result = new HashSet<GraphClass>();
		
		result.add(graph);
		new RevBFSWalker<GraphClass,Inclusion>( this.inclGraph,
                graph, null, GraphWalker.InitCode.DYNAMIC) {
            public void visit(GraphClass v) {
                result.add(v);
                if (recursive)
                {
                	super.visit(v);
                }
            }
        }.run();
        
        return result;
	}

	@Override
	public Map<Problem, Complexity> getComplexityMap(GraphClass graph) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Map<GraphClass, Complexity> getComplexityMap(Problem problem) {
		// TODO Auto-generated method stub
		return null;
	}

    public String getDate() {
        return date;
    }        
    
    public int getNodeCount() {
        return nodeCount;
    }    
    
    public int getEdgeCount() {
        return edgeCount;
    }    

    /**
     * Return a collection with the environment of the given node.
     * The environment is found by walking over open super/subclasses until the
     * first non-open node is reached.
     */
    private Collection<GraphClass> getNodesOpen(GraphClass node,
            final Problem problem) {
        /*final ArrayList<GraphClass> result = new ArrayList<GraphClass>();
        new UBFSWalker<GraphClass,Inclusion>(
                DataSet.inclGraph, node, null, GraphWalker.InitCode.DYNAMIC) {
            public void visit(GraphClass v) {
                result.add(v);
                Complexity c = problem.getComplexity(v);
                if (c.isUnknown())
                    super.visit(v);
                else
                    finish(v);
            }
        }.run();*/

        ArrayList<GraphClass> result = new ArrayList<GraphClass>();
        result.addAll(getNodesNP(node, problem));
        result.addAll(getNodesP(node, problem));

        return result;
    }


    /**
     * Return a collection with the environment of the given node.
     * The environment is found by walking over open subclasses until the
     * first polynomial node is reached.
     */
    private Collection<GraphClass> getNodesNP(GraphClass node,
            final Problem problem) {
        final ArrayList<GraphClass> result = new ArrayList<GraphClass>();
        new BFSWalker<GraphClass,Inclusion>(
                this.inclGraph, node, null, GraphWalker.InitCode.DYNAMIC) {
            public void visit(GraphClass v) {
                result.add(v);
                if (problem.getComplexity(v).betterOrEqual(Complexity.P))
                    finish(v);
                else
                    super.visit(v);
            }
        }.run();

        return result;
    }


    /**
     * Fills in a vector with the environment of the given node.
     * The environment is found by walking over open superclasses until the
     * first non-polynomial node is reached.
     */
    private Collection<GraphClass> getNodesP(GraphClass node,
            final Problem problem) {
        final ArrayList<GraphClass> result = new ArrayList<GraphClass>();
        new RevBFSWalker<GraphClass,Inclusion>(
                this.inclGraph, node, null, GraphWalker.InitCode.DYNAMIC) {
            public void visit(GraphClass v) {
                result.add(v);
                Complexity c = problem.getComplexity(v);
                if (c.likelyNotP())
                    finish(v);
                else
                    super.visit(v);
            }
        }.run();

        return result;
    }

    /**
     * Returns a vector with the environment of the node with the given name.
     * The environment depends on the complexity of the given node.
     */
    protected Collection<GraphClass> getNodes(GraphClass graph, Problem problem) {
        Complexity c = problem.getComplexity(graph);
        Collection<GraphClass> result = null;
        if (c.isUnknown())
            result = getNodesOpen(graph, problem);
        else if (c.betterOrEqual(Complexity.P))
            result = getNodesP(graph, problem);
        else if (c.likelyNotP())
            result = getNodesNP(graph, problem);
        else
            throw new RuntimeException("Bad node");
        return result;
    }

}
