/*
 * Layout a Digraph hierachically.
 *
 * $Header: /home/ux/CVSROOT/teo/teo/isgci/layout/HierarchyLayout.java,v 2.1 2011/09/29 08:52:51 ux Exp $
 *
 * This file is part of the Information System on Graph Classes and their
 * Inclusions (ISGCI) at http://www.graphclasses.org.
 * Email: isgci@graphclasses.org
 */

package teo.isgci.layout;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;

import y.base.Graph;
import y.base.Node;
import y.base.Edge;
import y.base.NodeCursor;
import y.base.EdgeCursor;

import y.base.NodeMap;
import y.base.EdgeMap;

import y.base.DataMap;
import y.base.NodeList;
import y.layout.hierarchic.IncrementalHierarchicLayouter;
import y.layout.hierarchic.incremental.IncrementalHintsFactory;
import y.option.ConstraintManager;
import y.option.OptionHandler;
import y.option.OptionItem;
import y.util.Maps;
import y.view.Graph2D;
import y.view.Graph2DLayoutExecutor;
import y.view.Graph2DViewActions;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JLabel;
import javax.swing.JToolBar;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Locale;


import teo.isgci.grapht.GAlg;
import teo.isgci.grapht.Annotation;
import teo.isgci.grapht.GraphWalker;
import teo.isgci.grapht.TreeDFSWalker;
import teo.isgci.grapht.WalkerInfo;
import teo.isgci.util.IntFunction;

/**
 * Calculates a hierarchy layout for a DAG. The graph should be transitively
 * reduced. If the graph is not acyclic or not transitively reduced, behaviour
 * of this class is undefined.
 */
public class HierarchyLayout<V,E> {
    /** The graph we're laying out */

	  public HierarchyLayout()
	  {
	    //instantiates an empty graph
	    Graph graph = new Graph();
	    
	    //create a temporary node array for fast lookup
	    Node[] tmpNodes = new Node[5];
	    
	    //create some nodes in the graph and store references in the array
	    for(int i = 0; i < 5; i++)
	    {
	      tmpNodes[i] = graph.createNode();
	    }
	    
	    //create some edges in the graph
	    for(int i = 0; i < 5; i++)
	    {
	      for(int j = i+1; j < 5; j++)
	      {
	        //create an edge from node at index i to node at index j
	        graph.createEdge(tmpNodes[i],tmpNodes[j]);
	      }
	    }
	    
	    
	    //output the nodes of the graph 
	    System.out.println("The nodes of the graph");
	    for(NodeCursor nc = graph.nodes(); nc.ok(); nc.next())
	    {
	      Node node = nc.node();
	      System.out.println(node);
	      System.out.println("in edges #" + node.inDegree());
	      for(EdgeCursor ec = node.inEdges(); ec.ok(); ec.next())
	      {
	        System.out.println(ec.edge());
	      }
	      System.out.println("out edges #" + node.outDegree());
	      for(EdgeCursor ec = node.outEdges(); ec.ok(); ec.next())
	      {
	        System.out.println(ec.edge());
	      }
	    }
	    
	      
	    //output the edges of the graph 
	    System.out.println("\nThe edges of the graph");
	    for(EdgeCursor ec = graph.edges(); ec.ok(); ec.next())
	    {
	      System.out.println(ec.edge());
	    }

	    //reverse edges that have consecutive neighbors in graph
	    //reversing means switching source and target node
	    for(EdgeCursor ec = graph.edges(); ec.ok(); ec.next())
	    {
	      if(Math.abs(ec.edge().source().index() - ec.edge().target().index()) == 1) 
	        graph.reverseEdge(ec.edge());
	    }
	    
	    System.out.println("\nthe edges of the graph after some edge reversal");
	    for(EdgeCursor ec = graph.edges(); ec.ok(); ec.next())
	    {
	      System.out.println(ec.edge());
	    }
	    
	    ///////////////////////////////////////////////////////////////////////////
	    // Node- and EdgeMap handling   ///////////////////////////////////////////
	    ///////////////////////////////////////////////////////////////////////////
	    
	    //create a nodemap for the graph
	    NodeMap nodeMap = graph.createNodeMap();
	    for(NodeCursor nc = graph.nodes(); nc.ok(); nc.next())
	    {
	      //get node at current cursor position
	      Node node = nc.node();
	      //associate descriptive String to the node via a nodemap 
	      nodeMap.set(node,"this is node " + node.index());
	    }
	    
	    //create an edgemap for the graph
	    EdgeMap edgeMap = graph.createEdgeMap();
	    for(EdgeCursor ec = graph.edges(); ec.ok(); ec.next())
	    {
	      //get edge at current cursor position
	      Edge edge = ec.edge();
	      //associate descriptive String to the edge via an edgemap
	      edgeMap.set(edge,"this is edge [" + 
	                  nodeMap.get(edge.source()) + "," + 
	                  nodeMap.get(edge.target()) + "]");
	    }
	    
	    //output the nodemap values of the nodes
	    System.out.println("\nThe node map values of the graph");
	    for(NodeCursor nc = graph.nodes(); nc.ok(); nc.next())
	    {
	      System.out.println(nodeMap.get(nc.node()));
	    }
	    
	    //output the edges of the graph 
	    System.out.println("\nThe edge map values of the graph");
	    for(EdgeCursor ec = graph.edges(); ec.ok(); ec.next())
	    {
	      System.out.println(edgeMap.get(ec.edge()));
	    }
	    
	    //cleanup unneeded node and edge maps again (free resources)
	    graph.disposeNodeMap(nodeMap);
	    graph.disposeEdgeMap(edgeMap);

	    ///////////////////////////////////////////////////////////////////////////
	    // removing elements from the graph  //////////////////////////////////////
	    ///////////////////////////////////////////////////////////////////////////
	    
	    for(NodeCursor nc = graph.nodes(); nc.ok(); nc.next())
	    {
	      //remove node that has a edge degree > 2
	      if(nc.node().degree() > 2)
	      {
	        //removed the node and all of its adjacent edges from the graph
	        graph.removeNode(nc.node());
	      }
	    }
	    System.out.println("\ngraph after some node removal");
	    System.out.println(graph);
	    
	    
	    
	  }
	  
	  public static void main(String[] args)
	  {
	    new HierarchyLayout();
	  }
	}

